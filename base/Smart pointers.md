Smart pointers - это мощный механизм во многих языках программирования для безопасного управления памятью.

Умные указатели представляют из себя структуры данных, работа которых схожа с работой указателей, но в то же время они обладают дополнительными метаданными и возможностями, по сравнению с обычными указателями и ссылками.

Rust с его концепцией владения и заимствования имеет дополнительное различие между ссылками и умными указателями.
- в то время, как ссылки только заимствуют данные, умные указатели часто _владеют_ данными, на которые указывают.

---

## $Box<T>$

Наиболее простой умный указатель - это _box_, тип которого записывается как `Box<T>`.

***Свойства:***
- используется для выделения области памяти на куче (heap).
	- на стеке хранится адрес выделенной области памяти на куче

- зачастую необходим при работе с [[Dynamically sized types]]
	- в частности при работе с trait-объектами необходимо их хранить в виде `Box<dyn Trait_name>`

- Единственное владение
	- Rust гарантирует, что только `Box<T>` владеет данными в любой момент времени
	- с помощью move-semantics `Box<T>` передает владение данными, а предыдущий владелец теряет к ней доступ
	- Когда `Box<T>` выходит из области видимости, выделенная память автоматически освобождается.

- Неизменяемость по умолчанию
	- попытка изменить данные по адресу выделенной памяти приведёт к противоречию концепции единственного владения.


### Случаи использования $Box<T>$


1. ***Хранение данных на куче***
``` Rust
let b = Box::new(5); // allocate memory on heap for i32 
```


2. ***Хранение рекурсивных типов***
	-  Рекурсивный тип - это тип, компонентой которого является сам этот тип
	- так как размер рекурсивного типа неизвестен на этапе компиляции, то необходимо хранить его в виде `Box<Rec_type>`

``` Rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); }
```


3. ***Передача владения на массивные данные***
	- при передачи массивных данных между функциями, удобно использовать `Box<T>`, так как в этом случае не будет происходить копирования передаваемых данных

``` Rust
fn process_large_data(data: Box<[i32; 1_000_000]>) {
    // something...
}

let large_data = Box::new([0; 1_000_000]);
process_large_data(large_data);
```


4. ***Хранение и взаимодействие с DST***
	- размер динамических типов данных неизвестен на этапе компиляции, а значит, что необходимо их "обернуть".

``` Rust
trait Draw {
    fn draw(&self);
}

struct Button;

impl Draw for Button {
    fn draw(&self) {
        println!("Drawing a button");
    }
}

let button: Box<dyn Draw> = Box::new(Button);
button.draw();
```


---

## $RC<T>$ (Reference counting)

$Rc<T>$ - это умный указатель, который предоставляет множественное владение объектом, благодаря счётчику ссылок.


- Счётчик ссылок внутри Rc<> позволяет контролировать число владельцев данного объекта. 
	- при появлении нового владельца -> счётчик ссылок инкрементируется
	- при отсутствии владельцев объект очищается из кучи, а счётчик обнуляется.

- используется только в однопоточном сценарии

- является аналогом std::shared_ptr<> в C++

- Rc<> не входит в список автоматического импорта прелюдии и его необходимо отдельно подключать : `use std::rc::Rc;`


``` Rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    
    println!("count after c goes out of scope = {}",Rc::strong_count(&a));
}
```

данный код наглядно показывает работу множественного наследования и состояние счётчика ссылок:

``` Rust
// OUTPUT

count after creating a = 1  
count after creating b = 2  
count after creating c = 3  
count after c goes out of scope = 2
```

---

## $Arc<T>$ (Atomic reference counting)

`Arc<T>` - это потокобезопасный вариант `Rc<T>`. 

Он использует атомарные операции для управления счётчиком ссылок, что позволяет безопасно использовать его в многопоточном программировании.   

***Свойства:***
- **Множественное владение в многопоточном окружении**: `Arc<T>` позволяет нескольким потокам иметь доступ к одним и тем же данным.

- **Атомарный счетчик ссылок**: `Arc<T>` использует атомарные операции для управления счетчиком ссылок, что обеспечивает безопасность в многопоточном окружении.

- **Неизменяемость**: также как и `Rc<T>`, `Arc<T>` обеспечивает неизменяемость данных. 
	- Для изменчивости в многопоточном окружении можно использовать `Mutex<T>` или `RwLock<T>` внутри `Arc<T>`.

``` Rust
use std::sync::Arc;
use std::thread;

fn expensive_computation() -> Arc<Vec<i32>> {
    Arc::new(vec![1, 2, 3, 4, 5])
}

fn main() {
    let cache = expensive_computation();

    let mut handles = vec![];

    for i in 0..5 {
        let cache_clone = Arc::clone(&cache);
        let handle = thread::spawn(move || {
            println!("Thread {} sees cache: {:?}", i, cache_clone);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

В этом примере, `cache` совместно используется пятью потоками. `Arc::clone` увеличивает счетчик ссылок атомарно, позволяя каждому потоку иметь доступ к кэшированным данным.

---

## Interior Mutability Pattern

Interior Mutability Pattern - это pattern проектирования в Rust, который позволяет изменять данные, даже при наличии неизменяемых ссылок на эти данные.
- Для изменения данных данный pattern использует unsafe код внутри структуры данных для обхода стандартных правил Rust, регулирующих изменяемость и заимствование

- Мы можем использовать типы, в которых применяется Interior mutability pattern, только если мы можем гарантировать, что правила заимствования будут соблюдаться во время выполнения, несмотря на то, что компилятор не сможет этого гарантировать. 
	- В этом случае `unsafe` код оборачивается безопасным API, и внешне тип остаётся неизменяемым.


$\triangle$ Данный pattern проектирования реализуется в Rust с помощью умного указателя RefCell<>.


---
## $RefCell<T>$

`RefCell<T>` - это умный указатель, который реализует Interior Mutability pattern, а именно предоставляет внутреннюю изменяемость.

В отличии от обычных ссылок и других умных указателей в языке Rust, `RefCell<T>`  позволяет изменять данные, находящиеся по адресу данного указателя. 

Внутренняя изменяемость `RefCell<T>` достигается за счёт проверки правил заимствования в процессе runtime, а не в процессе компиляции.


***Правила заимствования:***

- В любой момент времени может существовать только одна изменяемая ссылка (&mut T), либо любое количество неизменяемых ссылок (&T).

- Заимствования (ссылки) должны быть действительны в течении всего времени их использования.
	- => Ссылка не может пережить владельца объекта 


`RefCell<T>` не позволяет полностью обойти правила заимствования:
- средство проверки правил заимствования в компиляторе позволяет эту внутреннюю изменяемость, однако правила заимствования проверяются во время выполнения. 
- В случае нарушения правил, вместо ошибки компиляции вызовется `panic!`.


``` Rust
use std::cell::RefCell;

fn main() {
    let value = RefCell::new(42);

    {
        let mut value_borrowed = value.borrow_mut();
        *value_borrowed += 1;
    }

    {
        let value_borrowed = value.borrow();
        println!("Value: {}", value_borrowed);
    }
}
```


***Основные методы `RefCell<T>`:***

- `borrow()` - возвращает неизменяемую ссылку (`Ref<T>`) на объект.
- `borrow_mut()` - возвращает изменяемую ссылку (`RefMut<T>`) на объект.


Ещё один наглядный пример работы RefCell:

``` Rust
use std::cell::RefCell;

fn main() {
    let cell = RefCell::new(42);

    // taking Ref<T>
    let value = cell.borrow();
    println!("The value is: {}", *value); // Output: The value is: 42

    // taking RefMut<T>
    {
        let mut mut_value = cell.borrow_mut();
        *mut_value = 100;
    }

    let updated_value = cell.borrow();
    println!("The updated value is: {}", *updated_value);
    // Output: The updated value is: 100
}
```


---

## Reference cycles

